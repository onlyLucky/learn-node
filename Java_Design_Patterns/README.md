## 笔记

---

### **抽象工厂模式**

(class设计图纸）

#### **核心思想**
通过一个**抽象工厂接口**来定义一组相关对象的创建方法，而具体的对象创建则由**具体工厂类**实现。客户端代码通过抽象工厂接口操作，无需关心具体对象的创建细节。

#### **实现步骤**
1. **定义抽象工厂接口**：声明一组创建相关对象的方法，但不实现具体逻辑。
2. **实现具体工厂类**：每个具体工厂类实现抽象工厂接口，负责创建一组具体的产品对象。
3. **定义产品接口**：为每种类型的产品定义一个抽象接口。
4. **实现具体产品类**：每个具体产品类实现相应的产品接口。
5. **客户端使用**：客户端通过抽象工厂接口调用具体工厂来创建对象，无需直接实例化具体产品类。

#### **解决问题**
- **创建多个相关对象时**，避免直接依赖具体类。
- **支持多个产品族**，客户端代码可以根据需要选择不同的产品族。
- **解耦客户端与对象创建逻辑**，使系统更灵活、可扩展。

#### **优点**
- **解耦客户端与具体类**：客户端代码依赖抽象接口，不依赖具体实现。
- **易于扩展**：添加新的产品族时，只需新增具体工厂和产品类，无需修改现有代码。
- **支持产品族**：可以方便地切换不同产品族，客户端代码无需改变。

#### **缺点**
- **增加系统复杂度**：引入了额外的抽象层，代码量增加。
- **产品族必须完整**：如果某个产品族缺少某些产品，可能会导致客户端代码无法正常工作。
- **灵活性受限**：一旦产品族确定，难以添加新的产品类型。

#### **使用场景**
- **需要创建多个相关对象**，且对象的具体类可能在运行时动态决定。
- **支持多个产品族**，客户端代码需要根据不同的产品族创建一组相关对象。
- **系统需要独立于其产品的创建、组合和表示**，希望隐藏具体的实现细节。



#### **示例说明**
假设你正在开发一个图形界面库，需要支持不同操作系统（如 Windows 和 macOS）的按钮（Button）和文本框（TextBox）。

- **抽象工厂接口**：定义创建按钮和文本框的方法。
- **具体工厂类**：`WindowsFactory` 和 `MacOSFactory`，分别实现创建 Windows 和 macOS 风格的按钮和文本框。
- **产品接口**：`Button` 和 `TextBox`，定义按钮和文本框的通用方法。
- **具体产品类**：`WindowsButton`、`MacOSButton`、`WindowsTextBox`、`MacOSTextBox`。

客户端代码通过抽象工厂接口调用具体工厂来创建对象，无需关心具体实现，从而支持不同操作系统的界面风格切换。

---
   
### 生成器模式
class 构造函数参数过多

#### **核心思想**
将一个复杂对象的构建过程与其表示分离，通过逐步构建的方式来创建对象，使得相同的构建过程可以创建不同的表示。

#### **实现步骤**
1. **定义生成器接口**：声明创建复杂对象的各个步骤的方法。
2. **实现具体生成器类**：实现生成器接口，具体实现对象的构建过程。
3. **定义产品类**：定义复杂对象的结构，通常包含多个属性。
4. **创建指挥者类**：负责管理和控制生成器的构建过程，调用生成器的方法来逐步构建对象。
5. **客户端使用**：客户端通过指挥者类调用生成器来创建复杂对象。

#### **解决问题**
- **复杂对象的创建**：当一个对象的创建过程复杂，包含多个步骤和属性时，生成器模式可以简化创建过程。
- **避免构造函数的冗长和复杂**：避免使用多个参数的构造函数，使代码更清晰、易维护。
- **支持不同的构建过程**：可以使用不同的生成器实现来创建不同的对象表示。

#### **优点**
- **封装性好**：将对象的构建过程封装在生成器中，客户端无需关心具体实现。
- **灵活性高**：可以灵活地切换生成器实现，创建不同的对象表示。
- **简化客户端代码**：客户端只需调用指挥者类的方法，无需直接管理对象的构建过程。
- **支持逐步构建**：可以逐步构建复杂对象，便于扩展和维护。

#### **缺点**
- **代码量增加**：需要定义生成器接口、具体生成器类和指挥者类，代码量可能增加。
- **理解难度稍高**：对于初学者来说，理解生成器模式的结构和作用可能需要一定的时间。

#### **使用场景**
- **复杂对象的创建**：当对象的创建过程复杂，包含多个属性和步骤时。
- **需要灵活的构建过程**：当需要根据不同的需求创建不同配置的对象时。
- **避免构造函数的冗长**：当构造函数参数过多，导致代码难以维护时。
- **支持多种对象表示**：当需要根据不同的生成器实现创建不同的对象时。

#### **示例说明**
假设你正在开发一个汽车制造系统，汽车是一个复杂对象，包含多个属性（如发动机类型、轮胎数量、颜色等）。

- **生成器接口**：定义创建汽车的各个步骤的方法，如 `buildEngine()`、`buildTires()`、`buildColor()`。
- **具体生成器类**：`SUVBuilder` 和 `SedanBuilder`，分别实现创建 SUV 和轿车的具体步骤。
- **产品类**：`Car`，表示汽车对象，包含多个属性。
- **指挥者类**：`Director`，负责调用生成器的方法来逐步构建汽车对象。
- **客户端代码**：通过指挥者类调用生成器来创建汽车对象，无需直接管理构建过程。

---

### **原型模式（Prototype Pattern）**

#### **核心思想**
通过复制一个已存在的对象来创建新的对象，而不是通过新建操作（如 `new` 关键字）。这种方式可以避免复杂的初始化过程，同时允许动态地创建对象的副本。

#### **实现步骤**
1. **定义原型接口**：声明一个克隆方法（如 `clone()`），用于创建对象的副本。
2. **实现具体原型类**：实现原型接口，重写克隆方法，确保能够正确复制对象的状态。
3. **创建客户端代码**：客户端通过调用原型对象的克隆方法来创建新的对象副本，而无需直接使用 `new` 关键字。

#### **解决问题**
- **避免复杂的初始化过程**：当对象的创建过程复杂（例如需要执行大量的初始化操作）时，原型模式可以通过复制现有对象来简化创建过程。
- **动态创建对象**：允许客户端根据需要动态地创建对象的副本，而无需知道对象的具体类。
- **支持多种对象状态**：可以创建具有不同状态的对象副本，而无需重新初始化。

#### **优点**
- **简化对象创建过程**：通过复制现有对象，避免复杂的初始化逻辑。
- **提高性能**：克隆现有对象通常比通过 `new` 关键字创建新对象更快，尤其是当对象初始化过程复杂时。
- **支持动态创建**：客户端可以根据需要动态地创建对象副本，而无需知道对象的具体类。
- **易于扩展**：添加新的原型类时，无需修改现有代码，只需实现原型接口即可。

#### **缺点**
- **需要实现克隆方法**：每个需要支持克隆的对象类都需要实现克隆方法，这可能会增加代码的复杂性。
- **浅拷贝与深拷贝问题**：需要明确区分浅拷贝（复制引用）和深拷贝（复制对象），否则可能会导致错误。
- **依赖于具体类**：客户端代码需要依赖于具体的原型类，这可能会限制灵活性。

#### **使用场景**
- **对象创建过程复杂**：当对象的初始化过程复杂，且可以通过复制现有对象来简化时。
- **需要动态创建对象**：当客户端需要根据用户输入或其他条件动态创建对象副本时。
- **对象状态多变**：当需要创建具有不同状态的对象副本时。
- **性能优化**：当对象的创建成本较高，而克隆成本较低时。

#### **示例说明**
假设你正在开发一个图形编辑软件，用户可以创建和编辑各种图形（如圆形、矩形等）。用户希望可以通过复制现有图形来快速创建新的图形。

- **原型接口**：定义一个 `clone()` 方法，用于创建对象的副本。
- **具体原型类**：`Circle` 和 `Rectangle`，分别实现原型接口，重写 `clone()` 方法，确保可以正确复制图形的状态。
- **客户端代码**：用户通过图形编辑器选择一个图形，然后调用其 `clone()` 方法来创建新的图形副本。

---

### **单例模式（Singleton Pattern）**

#### **核心思想**
确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。通过控制实例的创建过程，保证全局只有一个对象实例。

#### **实现步骤**
1. **私有化构造函数**：将类的构造函数设置为私有，防止外部通过 `new` 关键字创建实例。
2. **提供一个私有静态实例**：在类内部定义一个私有的静态变量，用于存储唯一的实例。
3. **提供一个公共静态方法**：通过一个公共的静态方法来获取实例，如果实例不存在，则创建它；如果已存在，则直接返回。
4. **（可选）线程安全处理**：如果在多线程环境中使用，需要确保线程安全。

#### **解决问题**
- **全局唯一实例**：确保系统中某个类只有一个实例，避免重复创建导致的资源浪费或逻辑冲突。
- **提供全局访问点**：提供一个全局的访问点，方便系统中其他部分获取该实例。

#### **优点**
- **全局唯一性**：保证系统中只有一个实例，避免重复创建。
- **资源节约**：减少资源消耗，因为不需要多次创建实例。
- **易于管理**：通过一个全局访问点管理实例，逻辑清晰。

#### **缺点**
- **线程安全问题**：在多线程环境中，需要额外处理线程安全问题，否则可能导致多个实例被创建。
- **难以扩展**：单例类难以扩展，因为它的构造函数是私有的。
- **依赖全局状态**：单例模式依赖全局状态，可能会导致代码难以测试和维护。

#### **使用场景**
- **全局配置管理**：如日志记录器、配置文件管理器等，需要全局唯一访问点。
- **资源管理**：如数据库连接池、线程池等，需要控制资源的使用。
- **系统状态管理**：如应用程序的状态管理器，需要全局唯一实例来管理状态。
- **工具类**：如工具类或辅助类，不需要多个实例。

---

### **适配器模式（Adapter Pattern）**

#### **核心思想**
适配器模式通过创建一个适配器类，将一个类的接口转换为另一个类期望的接口，从而使原本不兼容的接口能够协同工作。它是一种结构型设计模式。

#### **实现步骤**
1. **定义目标接口**：这是客户端期望使用的接口。
2. **定义适配者类**：这是已经存在的类，但它的接口与目标接口不兼容。
3. **创建适配器类**：适配器类实现目标接口，并持有适配者类的实例。适配器类通过委托的方式调用适配者类的方法。
4. **在适配器类中实现目标接口的方法**：在适配器类中，将目标接口的方法调用委托给适配者类的方法。

#### **解决问题**
- **接口不兼容问题**：当两个类的接口不兼容，但需要协同工作时，适配器模式可以解决这个问题。
- **复用已有代码**：避免修改已有类的代码，通过适配器类将已有类的功能整合到新的系统中。

#### **优点**
- **提高复用性**：可以复用已有的类，而无需修改其代码。
- **增加灵活性**：可以动态地选择适配器，而无需修改客户端代码。
- **符合开闭原则**：在不修改已有代码的情况下，通过添加适配器类来扩展功能。

#### **缺点**
- **增加系统复杂度**：引入了额外的适配器类，可能会使系统结构变得复杂。
- **性能开销**：适配器类可能会引入额外的性能开销，尤其是在方法调用频繁的场景中。

#### **使用场景**
- **接口不兼容**：当需要将一个类的接口转换为另一个类期望的接口时。
- **复用已有代码**：当需要复用已有的类，但其接口与当前系统不兼容时。
- **第三方库集成**：当需要将第三方库的类集成到当前系统中，但接口不匹配时。

---

### **桥接模式（Bridge Pattern）**

有一个主体， 桥接类可以更换主体

#### **核心思想**
桥接模式通过将抽象与实现分离，使它们可以独立变化。它通过一个“桥接”类将抽象部分与实现部分连接起来，从而实现两者的解耦。

#### **实现步骤**
1. **定义抽象类**：定义一个抽象类，声明客户端需要使用的接口，但不实现具体的功能。
2. **定义实现接口**：定义一个接口或抽象类，声明实现部分的方法。
3. **创建具体实现类**：实现上述接口或抽象类，提供具体的实现逻辑。
4. **创建桥接类**：在抽象类中持有一个实现接口的引用，并将抽象类的操作委托给实现类。
5. **扩展抽象类和实现类**：根据需要扩展抽象类和实现类，而无需修改对方的代码。

#### **解决问题**
- **分离抽象与实现**：将抽象部分与实现部分分离，使它们可以独立变化。
- **避免类层次结构膨胀**：避免因继承导致的类层次结构过于复杂。
- **支持动态切换实现**：客户端可以在运行时动态切换具体的实现。

#### **优点**
- **分离抽象与实现**：抽象部分和实现部分可以独立变化，符合开闭原则。
- **扩展性好**：可以独立扩展抽象部分和实现部分，而无需修改对方的代码。
- **动态切换实现**：客户端可以在运行时动态切换具体的实现，增加了灵活性。
- **减少子类数量**：避免了因继承导致的类层次结构膨胀，减少了代码量。

#### **缺点**
- **增加系统复杂度**：引入了额外的抽象层，可能会使系统结构变得复杂。
- **理解难度稍高**：对于初学者来说，理解桥接模式的结构和作用可能需要一定的时间。

#### **使用场景**
- **抽象与实现分离**：当需要分离抽象部分与实现部分，使它们可以独立变化时。
- **避免类层次结构膨胀**：当继承导致类层次结构过于复杂时。
- **动态切换实现**：当需要在运行时动态切换具体的实现时。
- **多维度扩展**：当需要在多个维度上扩展类的功能时，例如支持多种设备和多种操作方式。

---

好的，以下是关于组合模式（Composite Pattern）的简洁明了说明：

---

### **组合模式（Composite Pattern）**

#### **核心思想**
组合模式将对象组合成树形结构，以表示“部分-整体”的层次关系。它让客户端可以统一地处理单个对象和对象组合，使得对单个对象和组合对象的使用具有一致性。

#### **实现步骤**
1. **定义组件接口**：声明所有对象（单个对象和组合对象）共有的操作接口。
2. **实现叶子组件**：表示单个对象，实现组件接口，不包含子组件。
3. **实现组合组件**：表示组合对象，实现组件接口，并管理子组件（如添加、删除子组件）。
4. **客户端使用**：通过组件接口操作对象，无需区分单个对象还是组合对象。

#### **解决问题**
- **部分-整体层次结构**：当需要表示对象的层次结构时，组合模式可以将单个对象和组合对象统一处理。
- **统一接口**：客户端可以一致地处理单个对象和组合对象，无需关心它们的具体类型。
- **动态组合对象**：可以在运行时动态地添加或删除子组件。

#### **优点**
- **结构清晰**：树形结构清晰，层次分明，便于理解和维护。
- **扩展性强**：可以轻松添加新的组件类型，而无需修改现有代码。
- **一致性高**：客户端可以一致地处理单个对象和组合对象，代码更加简洁。
- **动态性好**：可以在运行时动态地组合对象，灵活性高。

#### **缺点**
- **增加系统复杂度**：引入了额外的抽象层，可能会使系统结构变得复杂。
- **可能引入性能开销**：在组合对象较多时，递归调用可能会导致性能下降。
- **理解难度稍高**：对于初学者来说，理解组合模式的结构和作用可能需要一定的时间。

#### **使用场景**
- **部分-整体层次结构**：当需要表示对象的层次结构时，例如文件系统、组织架构等。
- **统一接口**：当需要统一处理单个对象和组合对象时。
- **动态组合对象**：当需要在运行时动态地组合对象时。
- **递归结构**：当对象之间存在递归关系时。

---






## Getting Started

Welcome to the VS Code Java world. Here is a guideline to help you get started to write Java code in Visual Studio Code.

## Folder Structure

The workspace contains two folders by default, where:

- `src`: the folder to maintain sources
- `lib`: the folder to maintain dependencies

Meanwhile, the compiled output files will be generated in the `dist` folder by default.

> If you want to customize the folder structure, open `.vscode/settings.json` and update the related settings there.

## Dependency Management

The `JAVA PROJECTS` view allows you to manage your dependencies. More details can be found [here](https://github.com/microsoft/vscode-java-dependency#manage-dependencies).

## 参考链接
[design-patterns-java](https://github.com/RefactoringGuru/design-patterns-java)